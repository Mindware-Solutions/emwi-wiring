$version 10.00

$rect <10,0,210,40>
inline HAL_Includes
{
  #include <stm32f7xx_hal.h>


}

$rect <10,50,210,90>
$output false
class Core
{
  // Internal functions.
  // Do not use outside the class.
  note group noteInternal
  {
    attr Bounds = <640,360,940,560>;
  }

  // Internal variables.
  note group noteInternal1
  {
    attr Bounds = <640,150,940,350>;
  }

  $rect <690,220,890,260>
  var Wiring::PinsClass pins = Wiring::Pins;

  // Core Wiring functions
  note group noteCore
  {
    attr Bounds = <10,10,230,350>;
  }

  // This method sets (aState = true) or resets (aState = false) a digital output \
  // pin on the Arduino connector.
  // Pins are identified by their pin number, digital pins 0 to 15, analog pins 16-21.
  $rect <20,100,220,140>
  method void digitalWrite( arg int32 aPin, arg bool aState )
  {
    // get the corresponding pin
    var Wiring::Pin pin = pins.Pin( aPin );
    // and set pin state based on aState
    // false = LOW
    // true = HIGH
    if ( pin != null )
      pin.State = aState ? Wiring::PinState.HIGH : Wiring::PinState.LOW;

  }

  // This method configures a pin from the Arduino connector.
  // Pins are identified by their pin number, digital pins 0 to 15, analog pins 16-21.
  // Possible modes:
  // Wiring::PinModes.INPUT - simple digital input
  // Wiring::PinModes.INPUT_PULLUP - simple digital input with internal pullup enabled
  // Wiring::PinModes.INPUT_PULLDOWN - simple digital input with internal pulldown \
  // enabled
  // Wiring::PinModes.OUTPUT - simple digital output in push-pull mode
  // Wiring::PinModes.OUTPUT_OD - simple digital output in open-drain mode
  // Wiring::PinModes.ANALOG_INPUT - analog (ADC) input mode
  $rect <20,60,220,100>
  method void pinMode( arg int32 aPin, arg Wiring::PinModes aMode )
  {
    var Wiring::Pin pin = pins.Pin( aPin );
    if ( pin != null )
    {
      pin.Mode = aMode;
    }
  }

  // This method reads the state of a digital input pin on the Arduino connector.
  // Pins are identified by their pin number, digital pins 0 to 15, analog pins 16-21.
  // Returns true if the pin is high, false if low.
  $rect <20,140,220,180>
  method bool digitalRead( arg int32 aPin )
  {
    // get the corresponding pin
    var Wiring::Pin pin = pins.Pin( aPin );
    // and set pin state based on aState
    // false = LOW
    // true = HIGH
    if ( pin != null )
      return pin.State == Wiring::PinState.HIGH;

    // if pin is not connected, always return false
    return false;

  }

  // This function sets the resolution for any further analog reads. Resolution in \
  // specified in the number of bits (between 1 and 32).
  // If the hardware does not support the given resolution then a lower resolution \
  // will be used on the actual read and then upscaled to the requested resolution.
  $rect <20,210,220,250>
  method int32 analogReadResolution( arg int32 aResolution )
  {
    /* The template just returns the given argument... */
    return aResolution;
  }

  $rect <690,260,890,300>
  var uint32 adc_resolution = 0;

  // Core Wiring properties
  note group noteCore1
  {
    attr Bounds = <240,10,460,350>;
  }

  $rect <250,210,450,250>
  property int32 AnalogReadResolution;

  $rect <250,250,450,290>
  onset AnalogReadResolution
  {
    // make sure it is within range
    if ( value < 1 )
      value = 1;
    if ( value > 32 )
      value = 32;

    // The value doesn't change - nothing to do.
    if ( pure AnalogReadResolution == value )
      return;

    // Remember the property's new value.
    pure AnalogReadResolution = value;

    // also configure the adc_resolution
    selectADCResolution( value );


  }

  $rect <680,440,880,480>
  method void selectADCResolution( arg int32 aRes )
  {
    // this function will select the best suited ADC resolution available on the underlying hardware
    var uint32 res = 0; // store the underlying configuration
    var int32 corr = 0; // correction factor to be used when converting to the requested resolution

    native ( res, corr, aRes )
    {
    #ifdef ADC_RESOLUTION_6B
      if ( aRes <= 6 )
      {
        res = ADC_RESOLUTION_6B;
        corr = aRes - 6;
      }
      else
    #endif
    #ifdef ADC_RESOLUTION_8B
      if ( aRes <= 8 )
      {
        res = ADC_RESOLUTION_8B;
        corr = aRes - 8;
      }
      else
    #endif
    #ifdef ADC_RESOLUTION_10B
      if ( aRes <= 10 )
      {
        res = ADC_RESOLUTION_10B;
        corr = aRes - 10;
      }
      else
    #endif
    #ifdef ADC_RESOLUTION_12B
      if ( aRes <= 12 )
      {
        res = ADC_RESOLUTION_12B;
        corr = aRes - 12;
      }
      else
    #endif
    #ifdef ADC_RESOLUTION_14B
      if ( aRes <= 14 )
      {
        res = ADC_RESOLUTION_14B;
        corr = aRes - 14;
      }
      else
    #endif
    #ifdef ADC_RESOLUTION_16B
      if ( aRes <= 16 )
      {
        res = ADC_RESOLUTION_16B;
        corr = aRes - 16;
      }
      else
    #endif
      {
        res = 0;
    #if defined(ADC_RESOLUTION_6B) && !ADC_RESOLUTION_6B
        corr = aRes - 6;
    #elif defined(ADC_RESOLUTION_8B) && !ADC_RESOLUTION_8B
        corr = aRes - 8;
    #elif defined(ADC_RESOLUTION_10B) && !ADC_RESOLUTION_10B
        corr = aRes - 10;
    #elif defined(ADC_RESOLUTION_12B) && !ADC_RESOLUTION_12B
        corr = aRes - 12;
    #elif defined(ADC_RESOLUTION_14B) && !ADC_RESOLUTION_14B
        corr = aRes - 14;
    #elif defined(ADC_RESOLUTION_16B) && !ADC_RESOLUTION_16B
        corr = aRes - 16;
    #endif
      }
    } 
            
    adc_resolution = res;
    adc_correction = corr;

  }

  $rect <690,300,890,340>
  var int32 adc_correction = 0;

  // Read the ADC conversion result from an analog input pin. Sampling will not work \
  // if pin is not configured correctly.
  $rect <19,251,219,291>
  method uint32 analogRead( arg int32 aPin )
  {
    // find the ADC needed
    var Wiring::Adc adc = pins.Adc( aPin );
    if ( adc == null )
    {
      return 0;
    }

    // perform a single conversion
    var uint16 a = adc.ReadAdcValue( adc_resolution );

    // and correct for the requested resolution
    if ( adc_correction == 0 )
    {
      return (uint32)a;
    }
    else if ( adc_correction > 0 )
    {
      // make a skewed bit shifting, so 0 will end up always 0, and MAX-1 will always end up with all bits of 1
      return (((uint32)a + 1) << adc_correction ) - 1;
    }
    else
    {
      if ( a < ( 1 << -adc_correction ))
        return 0;
      return (((uint32)a + 1) >> -adc_correction ) - 1;
    }
  }
}

$rect <220,50,420,90>
$output false
enum PinModes
{
  // Not connected pin
  $rect <10,190,210,230>
  item NC = 0;

  // Input mode
  $rect <10,40,210,80>
  item INPUT;

  // Input mode with pullup enabled
  $rect <210,40,410,80>
  item INPUT_PULLUP;

  // Input mode with pulldown enabled
  $rect <410,40,610,80>
  item INPUT_PULLDOWN;

  // Analog input mode
  $rect <610,40,810,80>
  item INPUT_ANALOG;

  // Push-pull output mode
  $rect <10,80,210,120>
  item OUTPUT;

  // Open-drain output mode
  $rect <210,80,410,120>
  item OUTPUT_OD;

  // Alternate function of the pin. Should not be used directly, but through the \
  // corresponding peripheral library.
  $rect <260,190,510,230>
  item ALTERNATE_FUNCTION;

  // Alternate function of the pin. Should not be used directly, but through the \
  // corresponding peripheral library.
  $rect <560,190,810,230>
  item ALTERNATE_FUNCTION_OD;

  // Mode selection for pins
  note group Note
  {
    attr Bounds = <0,0,820,130>;
  }

  // Internal settings. Should not be used directly
  note group Note1
  {
    attr Bounds = <0,150,820,240>;
  }
}

$rect <500,50,700,90>
$output false
class Pin
{
  $rect <0,160,200,200>
  var handle port = null;

  $rect <0,200,200,240>
  var uint16 pin = 0;

  // Attaches this class to a specific pin. Used only in the Board specific initialization \
  // variant.
  $rect <200,160,400,200>
  method void attach( arg Wiring::Port aPort, arg uint32 aPin )
  {
    // avoid warnings in prototyper
    $if $prototyper
      aPort;
      aPin;
    $endif

    $if !$prototyper
    var handle h;
    native (h, aPort)
    {
      switch ( aPort )
      {
        case WiringPortA:
          h = (XHandle)GPIOA;
          __HAL_RCC_GPIOA_CLK_ENABLE();
          break;
        case WiringPortB:
          h = (XHandle)GPIOB;
          __HAL_RCC_GPIOB_CLK_ENABLE();
          break;
        case WiringPortC:
          h = (XHandle)GPIOC;
          __HAL_RCC_GPIOC_CLK_ENABLE();
          break;
        case WiringPortD:
          h = (XHandle)GPIOD;
          __HAL_RCC_GPIOD_CLK_ENABLE();
          break;
        case WiringPortE:
          h = (XHandle)GPIOE;
          __HAL_RCC_GPIOE_CLK_ENABLE();
          break;
        case WiringPortF:
          h = (XHandle)GPIOF;
          __HAL_RCC_GPIOF_CLK_ENABLE();
          break;
        case WiringPortG:
          h = (XHandle)GPIOG;
          __HAL_RCC_GPIOG_CLK_ENABLE();
          break;
        case WiringPortH:
          h = (XHandle)GPIOH;
          __HAL_RCC_GPIOH_CLK_ENABLE();
          break;
        case WiringPortI:
          h = (XHandle)GPIOI;
          __HAL_RCC_GPIOI_CLK_ENABLE();
          break;
        case WiringPortJ:
          h = (XHandle)GPIOJ;
          __HAL_RCC_GPIOJ_CLK_ENABLE();
          break;
        case WiringPortK:
          h = (XHandle)GPIOK;
          __HAL_RCC_GPIOK_CLK_ENABLE();
          break;
        default:
          h = 0;
      }
    }
    port = h;
    $endif

    pin = (uint16)(1 << aPin);

  }

  $rect <0,0,200,40>
  property Wiring::PinModes Mode;

  $rect <0,40,200,80>
  onset Mode
  {
    // The value doesn't change - nothing to do.
    if ( pure Mode == value )
      return;

    // Remember the property's new value.
    pure Mode = value;

    // if pin is attached to a hardware pin, apply the settings
    $if !$prototyper
    if ( port != null )
    {
      var handle h = port;
      var uint16 i = pin;
      var uint32 mode = 0;
      var uint32 pull = 0;
      switch ( value )
      {
        case Wiring::PinModes.INPUT_PULLUP: pull = 1;
        case Wiring::PinModes.INPUT_PULLDOWN: pull = 2;
        case Wiring::PinModes.OUTPUT: mode = 1;
        case Wiring::PinModes.OUTPUT_OD: mode = 0x11;
        case Wiring::PinModes.INPUT_ANALOG:
          native ( mode )
          {
            mode = GPIO_MODE_ANALOG;
          }
        default: ;
      }

      native ( h, i, mode, pull )
      {
        GPIO_InitTypeDef init;

        /* enable port clock */
        __HAL_RCC_GPIOI_CLK_ENABLE();

        /* initialize pin */
        init.Pin = i;
        init.Mode = mode;
        init.Pull = pull;
        init.Speed = GPIO_SPEED_HIGH;
        HAL_GPIO_Init( (GPIO_TypeDef *)h, &init );
      }
    }



    $endif
  }

  $rect <200,0,400,40>
  property Wiring::PinState State;

  $rect <200,40,400,80>
  onset State
  {
    // The value doesn't change - nothing to do.
    if ( pure State == value )
      return;

    // Remember the property's new value.
    pure State = value;

    // set the corresponding state to the underlying hardware
    $if !$prototyper
    if ( port != null && value != Wiring::PinState.UNDEFINED && ( pure Mode == Wiring::PinModes.OUTPUT || pure Mode == Wiring::PinModes.OUTPUT_OD ))
    {
      var bool state = value == Wiring::PinState.HIGH;
      var handle h = port;
      var uint16 p = pin;
      native ( h, p, state )
      {
        HAL_GPIO_WritePin( (GPIO_TypeDef *)h, p, (GPIO_PinState)state);
      }
    }
    $endif

  }

  $rect <200,80,400,120>
  onget State
  {
    $if $prototyper
    return pure State;
    $endif

    $if !$prototyper
    // in inpput mode read directly from the the pin
    if ( pure Mode == Wiring::PinModes.INPUT ||
         pure Mode == Wiring::PinModes.INPUT_PULLUP ||
         pure Mode == Wiring::PinModes.INPUT_PULLDOWN )
    {
      var bool state;
      var handle h = port;
      var uint16 p = pin;
      native (state, h, p)
      {
        state = (XBool)HAL_GPIO_ReadPin((GPIO_TypeDef *)h, p);
      }
      return state ? Wiring::PinState.HIGH : Wiring::PinState.LOW;
    }
    else
    {
      return pure State;
    }
    $endif
  }
}

$rect <220,130,420,170>
$output false
enum Port
{
  $rect <10,10,210,50>
  item A;

  $rect <10,50,210,90>
  item B;

  $rect <10,90,210,130>
  item C;

  $rect <10,130,210,170>
  item D;

  $rect <10,170,210,210>
  item E;

  $rect <10,210,210,250>
  item F;

  $rect <10,250,210,290>
  item G;

  $rect <10,290,210,330>
  item H;

  $rect <10,330,210,370>
  item I;

  $rect <10,370,210,410>
  item J;

  $rect <10,410,210,450>
  item K;
}

$rect <500,90,700,130>
$output false
class PinsClass
{
  // This method will return a Pin object corresponding to the given pin number.
  $rect <0,0,200,40>
  method Wiring::Pin Pin( arg int32 aPin )
  {
    /* this should be overwritten in the board specific variant */
    aPin;
    throw "Unimplemented base class method";

  }

  // This method return the ADC channel associated with the pin. If there is no ADC \
  // channel on the requested pin, null is returned.
  $rect <0,40,200,80>
  method Wiring::Adc Adc( arg int32 aPin )
  {
    /* this should be overwritten in the board specific variant */
    aPin;
    throw "Unimplemented base class method";

  }
}

// Pin mapping on the STM23F746NG Discovery board
$rect <700,90,940,130>
$variant STM32F746
vclass Pins_STM32F746_DISCO : Wiring::PinsClass
{
  $rect <0,0,200,40>
  inherited method Init()
  {
    pins[0].attach( Wiring::Port.C, 7 );
    pins[1].attach( Wiring::Port.C, 6 );
    pins[2].attach( Wiring::Port.G, 6 );
    pins[3].attach( Wiring::Port.B, 4 );
    pins[4].attach( Wiring::Port.G, 7 );
    pins[5].attach( Wiring::Port.I, 0 );
    pins[6].attach( Wiring::Port.H, 6 );
    pins[7].attach( Wiring::Port.I, 3 );
    pins[8].attach( Wiring::Port.I, 2 );
    pins[9].attach( Wiring::Port.A, 15 );
    pins[10].attach( Wiring::Port.A, 8 );
    pins[11].attach( Wiring::Port.B, 15 );
    pins[12].attach( Wiring::Port.B, 14 );
    pins[13].attach( Wiring::Port.I, 1 );
    pins[14].attach( Wiring::Port.B, 9 );
    pins[15].attach( Wiring::Port.B, 8 );
    pins[16].attach( Wiring::Port.A, 0 );
    pins[17].attach( Wiring::Port.F, 10 );
    pins[18].attach( Wiring::Port.F, 9 );
    pins[19].attach( Wiring::Port.F, 8 );
    pins[20].attach( Wiring::Port.F, 7 );
    pins[21].attach( Wiring::Port.F, 6 );

  }

  $rect <0,40,200,80>
  inherited method Pin()
  {
    if ( aPin >= 0 && aPin < pins.size )
      return pins[aPin];
    else
      return null;

  }

  $rect <0,80,200,120>
  inherited method Adc()
  {
    // adc is not implemented in the prototyper
    $if $prototyper
      aPin;
      return null;
    $endif

    $if !$prototyper
      var uint32 channel;
      switch (aPin)
      {
        case 16:
          native (channel)
          {
            channel = ADC_CHANNEL_0;
          }   
        case 17:
          native (channel)
          {
            channel = ADC_CHANNEL_8;
          }   
        case 18:
          native (channel)
          {
            channel = ADC_CHANNEL_7;
          }   
        case 19:
          native (channel)
          {
            channel = ADC_CHANNEL_6;
          }   
        case 20:
          native (channel)
          {
            channel = ADC_CHANNEL_5;
          }   
        case 21:
          native (channel)
          {
            channel = ADC_CHANNEL_4;
          }   
        default:
          return null;
      }

      if ( adc3 == null )
      {
        adc3 = new Wiring::Adc;
        var handle h;
        native (h)
        {
          h = (XHandle)ADC3;
          __HAL_RCC_ADC3_CLK_ENABLE();
        }
        adc3.instance = h;
      }
      adc3.channel = channel;
      return adc3;
    $endif

  }

  $rect <200,40,400,80>
  array Wiring::Pin pins[ 22 ] =
  (
    Default[0] = new Wiring::Pin;
    Default[1] = new Wiring::Pin;
    Default[2] = new Wiring::Pin;
    Default[3] = new Wiring::Pin;
    Default[4] = new Wiring::Pin;
    Default[5] = new Wiring::Pin;
    Default[6] = new Wiring::Pin;
    Default[7] = new Wiring::Pin;
    Default[8] = new Wiring::Pin;
    Default[9] = new Wiring::Pin;
    Default[10] = new Wiring::Pin;
    Default[11] = new Wiring::Pin;
    Default[12] = new Wiring::Pin;
    Default[13] = new Wiring::Pin;
    Default[14] = new Wiring::Pin;
    Default[15] = new Wiring::Pin;
    Default[16] = new Wiring::Pin;
    Default[17] = new Wiring::Pin;
    Default[18] = new Wiring::Pin;
    Default[19] = new Wiring::Pin;
    Default[20] = new Wiring::Pin;
    Default[21] = new Wiring::Pin;
  );

  $rect <200,80,400,120>
  var Wiring::Adc adc3 = null;
}

$rect <500,130,700,170>
$output false
autoobject Wiring::PinsClass Pins;

// Enumeration of the possible pin states. Pin can be set to HIGH (resulting in a \
// logical 1 on the output), LOW (resulting a logical 0 on output) or UNDEFINED (this \
// has no effect on the output pin, and can appear when pin is routed to an alternate \
// function).
$rect <220,90,420,130>
$output false
enum PinState
{
  $rect <10,10,210,50>
  item UNDEFINED;

  $rect <10,50,210,90>
  item LOW;

  $rect <10,90,210,130>
  item HIGH;
}

$rect <500,170,700,210>
$output false
class Adc
{
  $rect <0,0,200,40>
  var handle instance = null;

  $rect <0,40,200,80>
  var uint32 channel = 0;

  // Perform a single conversion, waiting for the result and returning it;
  $rect <0,80,200,120>
  method uint16 ReadAdcValue( arg uint32 aResolution )
  {
    $if $prototyper
      aResolution;
      return 0;
    $endif

    $if !$prototyper
      if ( instance == null )
        return 0;

      var handle h = instance;
      var uint32 ch = channel;
      var uint16 res;
      
      native ( res, h, ch, aResolution )
      {
        // use default (zeroed) configuration everywhere
        ADC_HandleTypeDef AdcHandle = {};
        ADC_ChannelConfTypeDef AdcChannelConf = {};
        uint32_t c;

        AdcHandle.Instance = (ADC_TypeDef *)h;
        AdcHandle.Init.Resolution = aResolution;
        HAL_ADC_Init(&AdcHandle);

        AdcChannelConf.Channel = ch;
        AdcChannelConf.Rank = ADC_REGULAR_RANK_1;
        HAL_ADC_ConfigChannel( &AdcHandle, &AdcChannelConf );

        // start conversion
        HAL_ADC_Start(&AdcHandle);
        // and wait for finish it, it is not really healthy to do busy waiting in the GUI thread,
        // but we mimic the simple and inefficient Arduino routines
        HAL_ADC_PollForConversion( &AdcHandle, 10 );
        // polling could also end for some unforeseen reasons, so only continue if it terminated
        // at end-of-conversion
        c = HAL_ADC_GetState( &AdcHandle );
        if ( ( c & HAL_ADC_STATE_REG_EOC ) == HAL_ADC_STATE_REG_EOC )
        {
          res = HAL_ADC_GetValue( &AdcHandle );
        }
        // another rather inefficient Arduino handling, we start every conversion from initial setup
        // so in the end we also break down the setup
        HAL_ADC_Stop( &AdcHandle );
        HAL_ADC_DeInit( &AdcHandle );
      }
      return res;
    $endif
  }
}
